s_q = shannonEntropy(cc)
s_pq = shannonEntropy((p+cc)/2)
divergence = sum(s_pq - (s_p/2) - (s_q/2))
return(divergence)
}
constant <- function(p){
k = (0.5)/length(p)
a1 = (0.5 + k) * log(0.5 + k)
a2 = (length(p) - 1) * k * log(k)
a3 = (1 - 0.5) * log(length(p))
b = -1/(a1 + a2 + a3)
return(b)
}
Ccomplexity<-function(p){
cc <- jensenDivergence(p) * constant(p) * shannonEntropyNormalized(p)
return(cc)
}
woottersDistance<-function(p,q){
cc = rep(1/length(p),length(p))
distance = sum(sqrt(p*cc))
distance = acos(distance)
return(distance)
}
bhattacharyyaDistance<-function(p){
cc = rep(1/length(p),length(p))
distance = sum(sqrt(p*cc))
distance = -log(distance)
distance
}
harmonicMean<-function(p){
cc = rep(1/length(p),length(p))
harmonic = sum((p*cc)/(p+cc))
harmonic[is.nan(harmonic)||is.infinite(harmonic)] <- 0
return(2*harmonic)
}
distancePlane(cc,4,3,1)
library(ggplot2)
library(combinat)
partition<-function(series,size,delay){
myPartition = matrix(ncol=size,nrow=ceiling(length(series)/delay))
col = counter = i = 1
init =0
if(length(levels(series))!=0){
series = factor(series)
}
while(i <= length(series)){
myPartition[counter,col] = series[i]
col = col + 1
if((col - 1) == size){
i = init = init + delay
col = 1
counter = counter + 1
if((i + size + 1) > length(series)){
counter = counter - 1
break
}
}
i = i + 1
}
myPartition[1:(counter),]
}
entropyPlane<-function(serie,partition,dimension,delay,distribution,option,q=0){
entropy = rep(0,partition)
division = floor(length(serie)/partition)
init = 1
for(i in 1:partition){
myPartition = serie[init:(init+division)]
if(distribution == 1){
probability = distribution(myPartition,dimension,delay)
}else{
probability = WPE(myPartition,dimension,delay)
}
if(option == 1){
entropy[i] = shannonNormalized(probability)
}else if(option == 2){
entropy[i] = tsallisEntropy(probability,q)
}else if(option == 3){
entropy[i] = renyiEntropy(probability,q)
}else{
entropy[i] = PMEUnidimensional(probability)
}
init = init + division + 1
}
#png("myEntropy.png")
if(partition==1){
p = qplot(x=c(1:partition),y=entropy,geom="point",xlab="Partitions-Time Series",ylab="Entropy") +
ggtitle("Permutation Entropy Evolution") + theme(plot.title = element_text(hjust=0.5))
}
else{
p = qplot(x=c(1:partition),y=entropy,geom="line",xlab="Partitions-Time Series",ylab="Entropy") +
ggtitle("Permutation Entropy Evolution") + theme(plot.title = element_text(hjust=0.5))
}
print(p)
#dev.off()
return(entropy)
}
#Falta adicionar no relatÃ³rio
distancePlane<-function(serie,partition,dimension,delay,option=1,optionP=1,q=1){
distance = rep(0,partition)
division = floor(length(serie)/partition)
init = 1
for(i in 1:partition){
myPartition = serie[init:(init+division)]
if(optionP == 1){
probability = distribution(myPartition,dimension,delay)
}else{
probability = WPE(myPartition,dimension,delay)
}
if(option == 1){
distance[i] = euclidianDistance(probability)
}else if(option == 2){
distance[i] = squaredDistance(probability)
}else if(option == 3){
distance[i] = manhattanDistance(probability)
}else if(option == 4){
distance[i] = chebyshevDistance(probability)
}else if(option == 5){
distance[i] = kullbackDivergence(probability)
}else if(option == 6){
distance[i] = hellingerDistance(probability)
}else if(option == 7){
distance[i] = jensenDivergence(probability)
}else if(option == 8){
distance[i] = woottersDistance(probability,q)
}else if(option == 9){
distance[i] = bhattacharyyaDistance(probability,q)
}else{
cat("Distance option unavailable\n")
}
init = init + division + 1
}
#png("myEntropy.png")
if(partition==1){
p = qplot(x=c(1:partition),y=distance,geom="point",xlab="Partitions-Time Series",ylab="Distance") +
ggtitle("Stochastic distance Evolution") + theme(plot.title = element_text(hjust=0.5))
}
else{
p = qplot(x=c(1:partition),y=distance,geom="line",xlab="Partitions-Time Series",ylab="Distance") +
ggtitle("Stochastic distance Evolution") + theme(plot.title = element_text(hjust=0.5))
}
print(p)
#dev.off()
return(distance)
}
library(ggplot2)
library(combinat)
partition<-function(series,size,delay){
myPartition = matrix(ncol=size,nrow=ceiling(length(series)/delay))
col = counter = i = 1
init =0
if(length(levels(series))!=0){
series = factor(series)
}
while(i <= length(series)){
myPartition[counter,col] = series[i]
col = col + 1
if((col - 1) == size){
i = init = init + delay
col = 1
counter = counter + 1
if((i + size + 1) > length(series)){
counter = counter - 1
break
}
}
i = i + 1
}
myPartition[1:(counter),]
}
entropyPlane<-function(serie,partition,dimension,delay,distribution,option,q=0){
entropy = rep(0,partition)
division = floor(length(serie)/partition)
init = 1
for(i in 1:partition){
myPartition = serie[init:(init+division)]
if(distribution == 1){
probability = distribution(myPartition,dimension,delay)
}else{
probability = WPE(myPartition,dimension,delay)
}
if(option == 1){
entropy[i] = shannonNormalized(probability)
}else if(option == 2){
entropy[i] = tsallisEntropy(probability,q)
}else if(option == 3){
entropy[i] = renyiEntropy(probability,q)
}else{
entropy[i] = PMEUnidimensional(probability)
}
init = init + division + 1
}
#png("myEntropy.png")
if(partition==1){
p = qplot(x=c(1:partition),y=entropy,geom="point",xlab="Partitions-Time Series",ylab="Entropy") +
ggtitle("Permutation Entropy Evolution") + theme(plot.title = element_text(hjust=0.5))
}
else{
p = qplot(x=c(1:partition),y=entropy,geom="line",xlab="Partitions-Time Series",ylab="Entropy") +
ggtitle("Permutation Entropy Evolution") + theme(plot.title = element_text(hjust=0.5))
}
print(p)
#dev.off()
return(entropy)
}
#Falta adicionar no relatÃ³rio
distancePlane<-function(serie,partition,dimension,delay,option=1,optionP=1,q=1){
distance = rep(0,partition)
division = floor(length(serie)/partition)
init = 1
for(i in 1:partition){
myPartition = serie[init:(init+division)]
if(optionP == 1){
probability = distribution(myPartition,dimension,delay)
}else{
probability = WPE(myPartition,dimension,delay)
}
if(option == 1){
distance[i] = euclidianDistance(probability)
}else if(option == 2){
distance[i] = squaredDistance(probability)
}else if(option == 3){
distance[i] = manhattanDistance(probability)
}else if(option == 4){
distance[i] = chebyshevDistance(probability)
}else if(option == 5){
distance[i] = kullbackDivergence(probability)
}else if(option == 6){
distance[i] = hellingerDistance(probability)
}else if(option == 7){
distance[i] = jensenDivergence(probability)
}else if(option == 8){
distance[i] = woottersDistance(probability,q)
}else if(option == 9){
distance[i] = bhattacharyyaDistance(probability,q)
}else{
cat("Distance option unavailable\n")
}
init = init + division + 1
}
#png("myEntropy.png")
if(partition==1){
p = qplot(x=c(1:partition),y=distance,geom="point",xlab="Partitions-Time Series",ylab="Distance") +
ggtitle("Stochastic distance Evolution") + theme(plot.title = element_text(hjust=0.5))
}
else{
p = qplot(x=c(1:partition),y=distance,geom="line",xlab="Partitions-Time Series",ylab="Distance") +
ggtitle("Stochastic distance Evolution") + theme(plot.title = element_text(hjust=0.5))
}
print(p)
#dev.off()
return(distance)
}
distancePlane(cc,4,3,1)
library(ggplot2)
require(ggthemes)
readingMPR<-function(dimension,option=0){
if(dimension == 3){
continua = "continuaN6.txt"
trozo = "trozosN6.txt"
}
if(dimension == 4){
continua = "continuaN24.txt"
trozo = "trozosN24.txt"
}
if(dimension == 5){
continua = "continuaN120.txt"
trozo = "trozosN120.txt"
}
if(dimension == 6){
continua = "continuaN720.txt"
trozo = "trozosN720.txt"
}
curva1x = Read_txt(continua,1)
if(option==1) return(curva1x)
curva1y = Read_txt(continua,2)
if(option==2) return(curva1y)
curva2x = Read_txt(trozo,1)
if(option==3) return(curva2x)
curva2y = Read_txt(trozo,2)
if(option==4) return(curva2y)
}
# Partition indicates the number of parts in which we divide the series
partitionMPR<-function(serie,dimension,delay,partition){
complexity = entropy = rep(0,partition)
div = floor(length(serie)/partition)
if(partition != 1){
for(i in 1:partition){
initial = ((i-1)*div)
end = initial + div
if(i == 1){
initial = 1
end = div
}
aux = serie[initial:end]
probability = distribution(aux,dimension,delay)
entropy[i] = shannonEntropyNormalized(probability)
complexity[i] = Ccomplexity(probability)
}
}
else{
probability = distribution(serie,dimension,delay)
entropy = shannonEntropyNormalized(probability)
complexity = Ccomplexity(probability)
}
c1x = readingMPR(dimension,1)
c1y = readingMPR(dimension,2)
c2x = readingMPR(dimension,3)
c2y = readingMPR(dimension,4)
#png("myHC.png")
p = qplot(x=c2x,y=c2y,geom="line",xlab="Shannon Entropy",ylab="MPR Statistical Complexity") +
ggtitle("Entropy-Complexity Plane") + theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c1x,c1y)) + geom_point(aes(x=entropy,y=complexity),color="blue")
print(p)
#dev.off()
data = matrix(nrow = partition, ncol = 2)
data[,1] = entropy
data[,2] = complexity
return(data)
}
partitionMPR(c,3,1,4)
#Leitura de dados em arquivos#
#Leitura do arquivo .txt e armazenamento do conte?do em um array#
Read_txt<-function(name,column){
data = read.table(name, stringsAsFactors=FALSE, fileEncoding="latin1")
data = data[,column]
if(mode(data)=="character"){
data = type.convert(data)
}
data = na.omit(data)
return(data)
}
Read_txt2<-function(column){
data = read.table(file.choose())
data = data[,column]
data = na.omit(data)
return(data)
}
#Leitura do arquivo .csv e armazenamento do conte?do em um array#
Read_csv<-function(column,separador=";"){
data=read.csv(file.choose(), stringsAsFactors=T, fileEncoding="latin1",sep=separador)
data = data[,column]
if(mode(data)=="character"){
data = type.convert(data)
}
data = na.omit(data)
return(data)
}
#option == 0 -> Manter os valores repetidos
#Option != 0 -> Retirar os valores repetidos
Read_csv_interface<-function(file, column, option = 0){
time=read.csv(svalue(file), stringsAsFactors=T, fileEncoding="latin1",sep=";")
time = time[,column]
if(mode(time)=="character"){
time = type.convert(time)
}
time = na.omit(time)
if(option!=0) time = unique(time)
return(time)
}
partitionMPR(c,3,1,4)
library(ggplot2)
lookupTable<-function(){
lookup=unlist(read.table("lookupTable.txt"))
matrix(lookup,nrow=9,byrow=T)
}
# O valor de numberSymbols varia de 3 a 10
breakpoints<-function(numberSymbols){
numberSymbols = numberSymbols - 2
lookup = lookupTable()
na.omit(lookup[,numberSymbols])
}
zNormalization<-function(serie){
(serie - mean(serie))/sd(serie)
}
saxPlot<-function(serie,numberSymbols,size){
letters = c("a","b","c","d","e","f","g","h","j","k")
sax = ""
serie = zNormalization(serie)
segm = rep(0,size+1)
Psax = rep(0,size)
segm[1:size] = paa(serie,size)
segm[size+1] = segm[size]
point = breakpoints(numberSymbols)
for(i in 1:size){
aux = 0
for(j in 1:length(point)){
if(segm[i] <= point[j]){
sax = paste(letters[j],sax,sep="")
Psax[i] = j
aux = 1
break
}
}
if(!aux){
sax = paste(letters[numberSymbols+1],sax,sep="")
Psax[i] = numberSymbols+1
}
}
steps = data.frame(x=vline,y=segm)
#png("mySAX.png")
p = qplot(geom="line",xlab="Time",ylab="Serie") +
ggtitle("Symbolic Aggregate Approximation") + theme(plot.title = element_text(hjust=0.5)) +
geom_hline(yintercept=point) + geom_step(data = steps,aes(x=x,y=y),colour="black") +
geom_text(aes(x=(vline[1:(length(vline)-1)]+vline[2:length(vline)])/2,y=segm[1:(length(segm)-1)],label=letters[Psax],colour="red"))
print(p)
#dev.off()
return(sax)
}
library(ggplot2)
paa <- function(serie,size){
res = rep(0,size)
for(i in 0:(length(serie)*size-1)){
res[i%/%length(serie)+1] = res[i%/%length(serie)+1] + serie[i%/%size+1]
}
for(i in 1:size){
res[i]=res[i]/length(serie)
}
res
}
plotPAA<-function(serie,size,option=0){
vline=seq(from=0,to=length(serie),by=(length(serie)/size))
segm = rep(0,size+1)
segm[1:size] = paa(serie,size)
segm[size+1] = segm[size]
steps = data.frame(x=vline,y=segm)
segm = as.double(format(round(segm,2),nsmall=2))
myText = segm[1:size]
#png("myPAA.png")
p = qplot(x=c(1:length(serie)),y=serie,geom="line",xlab="Time",ylab="Serie",colour="red") +
ggtitle("Piecewise Aggregate Approximation") + theme(plot.title = element_text(hjust=0.5)) +
geom_step(data=steps,aes(x=x,y=y),colour="black") +
geom_text(aes(x=(vline[1:(length(vline)-1)]+vline[2:length(vline)])/2,y=segm[1:(length(segm)-1)]*1.05,label=myText,colour="blue"))
print(p)
#dev.off()
return(segm[1:size])
}
sum_of_variation<-function(segment){
c1 = segment[1:(length(segment)-1)]
c2 = segment[2:length(segment)]
res = sum(abs(c1-c2))
res
}
ssv<-function(serie,size){
aux = matrix(nrow=round(length(serie)/size),ncol=size)
res = rep(0,round(length(serie)/size))
ini = row = sum = i = 1
while((i <= length(serie)) && (row <= round(length(serie)/size))){
aux[row,sum] = serie[i]
if(sum == size){
row = row + 1
sum = 1
i = ini + size - 1
ini = i
}else{
i = i + 1
sum = sum + 1
}
}
for(i in 1:round(length(serie)/size)){
res[i] = sum_of_variation(aux[i,])
}
res
}
library(ggplot2)
PIP<-function(serie,numberPIPs){
pip=result=rep(0,numberPIPs)
texto = c(1:numberPIPs)
x1 = pip[1] = result[1] = 1
x2 = pip[2] = result[2] = length(serie)
y1 = serie[x1]
y2 = serie[x2]
initial = 1
n = 2
p = qplot(x=c(1:length(serie)),y=serie,xlab="Time",ylab="Serie",colour="blue") +
ggtitle("Perceptually Important Points") + theme(plot.title = element_text(hjust=0.5)) +
geom_line(aes(x=c(1:length(serie)),y=serie))
for(i in 3:numberPIPs){
pip[1:n] = sort(pip[1:n])
dis = rep(0,length(serie))
x1 = pip[initial]
y1 = serie[x1]
x2 = pip[initial+1]
y2 = serie[x2]
for(j in 1:(length(serie))){
x3 = j
y3 = serie[x3]
dis[j] = abs((y1 + (y2 - y1)*((x3-x1)/(x2-x1))) - y3)
if(dis[j] == max(dis)){
pip[n+1] = j
}
if(j == x2){
if(j != length(serie)){
initial = initial + 1
x1 = pip[initial]
y1 = serie[x1]
x2 = pip[initial+1]
y2 = serie[x2]
}
}
}
n = n + 1
initial = 1
result[n] = pip[n]
}
pip = sort(pip)
#png("myPIP.png")
p = p + geom_line(aes(x=pip,y=serie[pip]),colour="red") +
geom_text(aes(x=pip,y=serie[pip]*1.1,label=texto,colour="black"))
print(p)
#dev.off()
return(result)
}
