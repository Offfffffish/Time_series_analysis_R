p_patterns <- formationPattern(serie,dimension,delay)
print(p_patterns)
p_patterns <- newPatterns(p_patterns)
print(p_patterns)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
probability
}
formationPattern(a,3,1)
#Bibliotecas utilizadas#
library(combinat)
definePatterns<-function(dimension){
symbol = matrix(unlist(permn(dimension)),nrow = factorial(dimension),ncol = dimension)
}
formationPattern<-function(series,dimension,delay){
n_symbols = i = 1
n = length(series)
p_patterns = matrix(nrow=n,ncol=dimension)
index = c(0:(dimension-1))
while(i <= n){
first = i
if((i+dimension-1)<=n){
p_patterns[n_symbols,] = index[order(series[i:(i+dimension-1)])]
i = first + delay
n_symbols = n_symbols + 1
}else break
}
p_patterns = na.omit(p_patterns)
p_patterns[1:dim(p_patterns)[1],]
}
distribution<-function(serie,dimension,delay){
fat = factorial(dimension)
probability = rep(0,fat)
p_patterns <- formationPattern(serie,dimension,delay)
p_patterns <- newPatterns(p_patterns)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
}
definePatterns(3)
a = definePatterns(3)
a
#Bibliotecas utilizadas#
library(combinat)
definePatterns<-function(dimension){
symbol = matrix(unlist(permn(dimension)),nrow = factorial(dimension),ncol = dimension)
symbol
}
formationPattern<-function(series,dimension,delay){
n_symbols = i = 1
n = length(series)
p_patterns = matrix(nrow=n,ncol=dimension)
index = c(0:(dimension-1))
while(i <= n){
first = i
if((i+dimension-1)<=n){
p_patterns[n_symbols,] = index[order(series[i:(i+dimension-1)])]
i = first + delay
n_symbols = n_symbols + 1
}else break
}
p_patterns = na.omit(p_patterns)
p_patterns[1:dim(p_patterns)[1],]
}
distribution<-function(serie,dimension,delay){
fat = factorial(dimension)
probability = rep(0,fat)
p_patterns <- formationPattern(serie,dimension,delay)
p_patterns <- newPatterns(p_patterns)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
probability
}
definePatterns(3)
#Bibliotecas utilizadas#
library(combinat)
definePatterns<-function(dimension){
symbol = matrix(unlist(permn(dimension)),nrow = factorial(dimension),ncol = dimension)
symbol
}
formationPattern<-function(series,dimension,delay){
n_symbols = i = 1
n = length(series)
p_patterns = matrix(nrow=n,ncol=dimension)
index = c(0:(dimension-1))
while(i <= n){
first = i
if((i+dimension-1)<=n){
p_patterns[n_symbols,] = index[order(series[i:(i+dimension-1)])]
i = first + delay
n_symbols = n_symbols + 1
}else break
}
p_patterns = na.omit(p_patterns)
p_patterns[1:dim(p_patterns)[1],]
}
distribution<-function(serie,dimension,delay){
fat = factorial(dimension)
probability = rep(0,fat)
p_patterns <- formationPattern(serie,dimension,delay)
p_patterns <- newPatterns(p_patterns)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
probability
}
permn(3)
definePatterns(3)
permn(dimension)
dimension = 3
permn(dimension)
unlist(permn(dimension))
?matrix
#Bibliotecas utilizadas#
library(combinat)
definePatterns<-function(dimension){
symbol = matrix(unlist(permn(dimension)),nrow = factorial(dimension),ncol = dimension,byrow = TRUE)
symbol
}
formationPattern<-function(series,dimension,delay){
n_symbols = i = 1
n = length(series)
p_patterns = matrix(nrow=n,ncol=dimension)
index = c(0:(dimension-1))
while(i <= n){
first = i
if((i+dimension-1)<=n){
p_patterns[n_symbols,] = index[order(series[i:(i+dimension-1)])]
i = first + delay
n_symbols = n_symbols + 1
}else break
}
p_patterns = na.omit(p_patterns)
p_patterns[1:dim(p_patterns)[1],]
}
distribution<-function(serie,dimension,delay){
fat = factorial(dimension)
probability = rep(0,fat)
p_patterns <- formationPattern(serie,dimension,delay)
p_patterns <- newPatterns(p_patterns)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
probability
}
definePatterns(3)
a
a = c(2,4,7,1,3,9,8,6)
formationPattern(a,31)
formationPattern(a,3,1)
a = c(2,3,2)
formationPattern(a,3,1)
a = c(2,2,2)
formationPattern(a,3,1)
a = c(2,4,7,1,3,9,8,6)
b =formationPattern(a,3,1)
prop.table(b)
?prop.table
s = c(1,2,1,3)
prop.table(s)
ss = unique(prop.table(s))
s
ss
sss = sum(ss)
sss
sum(prop.table(s))
a
b
prop.table(b[1:6,])
b[1:6,]
?hist
hist(a,freq = FALSE)
g = hist(a,freq = FALSE)
g
a
a
b = definePatterns(3)
b
c = formationPattern(a,3,1)
c
bb = b - 1
bb
b
#Bibliotecas utilizadas#
library(combinat)
definePatterns<-function(dimension){
symbol = matrix(unlist(permn(dimension)),nrow = factorial(dimension),ncol = dimension,byrow = TRUE)
symbol = symbol - 1
symbol
}
formationPattern<-function(series,dimension,delay){
n_symbols = i = 1
n = length(series)
p_patterns = matrix(nrow=n,ncol=dimension)
index = c(0:(dimension-1))
while(i <= n){
first = i
if((i+dimension-1)<=n){
p_patterns[n_symbols,] = index[order(series[i:(i+dimension-1)])]
i = first + delay
n_symbols = n_symbols + 1
}else break
}
p_patterns = na.omit(p_patterns)
p_patterns[1:dim(p_patterns)[1],]
}
distribution<-function(serie,dimension,delay){
fat = factorial(dimension)
probability = rep(0,fat)
p_patterns <- formationPattern(serie,dimension,delay)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
probability
}
#Bibliotecas utilizadas#
library(combinat)
definePatterns<-function(dimension){
symbol = matrix(unlist(permn(dimension)),nrow = factorial(dimension),ncol = dimension,byrow = TRUE)
symbol = symbol - 1
symbol
}
formationPattern<-function(series,dimension,delay){
n_symbols = i = 1
n = length(series)
p_patterns = matrix(nrow=n,ncol=dimension)
index = c(0:(dimension-1))
while(i <= n){
first = i
if((i+dimension-1)<=n){
p_patterns[n_symbols,] = index[order(series[i:(i+dimension-1)])]
i = first + delay
n_symbols = n_symbols + 1
}else break
}
p_patterns = na.omit(p_patterns)
p_patterns[1:dim(p_patterns)[1],]
}
distribution<-function(serie,dimension,delay){
fat = factorial(dimension)
probability = rep(0,fat)
p_patterns <- formationPattern(serie,dimension,delay)
n_symbols <- dim(p_patterns)[1]
symbols <- definePatterns(dimension)
for(i in 1:fat){
for(j in 1:n_symbols){
if(all(p_patterns[j,] == symbols[i,])){
probability[i]=probability[i]+1
}
}
}
probability = probability/n_symbols
probability
}
a
b = definePatterns(3)
c = formationPattern(a,3,1)
b
c
all(c[1,]==b)
all(c[1,]==b[1,])
definePatterns(4)
library(statcomp)
library(statcomp)
ordinal_pattern_distribution(a,3)
distribution(a,3,1)
ordinal_pattern_time_series(a,3)
ordinal_pattern_distribution
install.packages("entropart")
library(entropart)
library(entropart)
?Tsallis
d = distribution(a,3,1)
d
Tsallis(d)
shannonEntropy <- function(probability){
h <- probability * log(probability)
h[is.nan(h)] <- 0
return(-sum(h))
}
shannonEntropyNormalized <- function(probability){
return(shannonEntropy(probability)/log(length(probability)))
}
tsallisEntropy <- function(probability,q){
entropy = sum(probability^q)
entropy = (1 - entropy)*(1/(q - 1))
entropy
}
tsallisEntropyNormalized <- function(probability,q){
ent_max = (1 - (length(probability)^(1 - q)))/(q - 1)
return(tsallisEntropy(probability,q)/ent_max)
}
renyiEntropy <- function(probability,q){
entropy = sum(probability^q)
entropy = log(entropy)
entropy = entropy * (1/(1 - q))
entropy
}
renyiEntropyNormalized <- function(probability,q){
return(renyiEntropy(probability,q)/log(length(probability)))
}
Tsallis(d)
tsallisEntropy(d,1)
shannonEntropyNormalized(d)
shannonEntropy(d)
Tsallis(d,q=0.1)
tsallisEntropy(d,0.1)
tsallisEntropyNormalized(d,0.1)
Tsallis
global_complexity
MPR_complexity
ln(10)
log(exp(1))
euclidian_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum((probability-cc)^2)
return(sqrt(distance))
}
euclidian_quadratica_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum((probability-cc)^2)
return(distance)
}
manhattan_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum(abs(probability-cc))
return(distance)
}
chebyshev_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
L = abs(probability - cc)
return(max(L))
}
kullback_leibler_divergence<-function(probability){
cc = rep(1/length(probability),length(probability))
distance <- probability * log(probability/cc)
distance[is.nan(distance)] <- 0
return(sum(distance))
}
kullbach_aux<-function(p,q){
distance <- p * log(p/q)
distance[is.nan(distance)||is.infinite(distance)]<-0
return(sum(distance))
}
hellinger_Distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum((sqrt(probability)-sqrt(cc))^2)*0.5
return(sqrt(distance))
}
jensenDivergence<-function(p){
q = rep(1/length(p),length(p))
s_p = shannonEntropy(p)
s_q = shannonEntropy(q)
s_pq = shannonEntropy((p+q)/2)
divergence = sum( s_pq - (s_p/2) - (s_q/2))
return(divergence)
}
constant <- function(p){
k = (0.5)/length(p)
a1 = (0.5 + k) * log(0.5 + k)
a2 = (length(p) - 1) * k * log(k)
a3 = (1 - 0.5) * log(length(p))
b = -1/(a1 + a2 + a3)
return(b)
}
Ccomplexity<-function(p){
cc <- jensenDivergence(p) * constant(p) * shannonEntropyNormalized(p)
return(cc)
}
wootters_distance<-function(probability,q){
cc = rep(1/length(probability),length(probability))
dis = sum(sqrt(probability*cc))
dis = acos(dis)
return(dis)
}
complexityF<-function(probability){
entropy = ShannonAux(probability)
qInitial = rep(1/length(probability),length(probability))
qInitial[1] = 1
desequilibrium = jensenDivergence(qInitial) * jensenDivergence(probability)
comp = entropy * desequilibrium
return(comp)
}
bhattacharyyaDistance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum(sqrt(probability*cc))
distance = -log(distance)
}
d
bhattacharyyaDistance(d)
euclidian_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum((probability-cc)^2)
return(sqrt(distance))
}
euclidian_quadratica_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum((probability-cc)^2)
return(distance)
}
manhattan_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum(abs(probability-cc))
return(distance)
}
chebyshev_distance<-function(probability){
cc = rep(1/length(probability),length(probability))
L = abs(probability - cc)
return(max(L))
}
kullback_leibler_divergence<-function(probability){
cc = rep(1/length(probability),length(probability))
distance <- probability * log(probability/cc)
distance[is.nan(distance)] <- 0
return(sum(distance))
}
kullbach_aux<-function(p,q){
distance <- p * log(p/q)
distance[is.nan(distance)||is.infinite(distance)]<-0
return(sum(distance))
}
hellinger_Distance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum((sqrt(probability)-sqrt(cc))^2)*0.5
return(sqrt(distance))
}
jensenDivergence<-function(p){
q = rep(1/length(p),length(p))
s_p = shannonEntropy(p)
s_q = shannonEntropy(q)
s_pq = shannonEntropy((p+q)/2)
divergence = sum( s_pq - (s_p/2) - (s_q/2))
return(divergence)
}
constant <- function(p){
k = (0.5)/length(p)
a1 = (0.5 + k) * log(0.5 + k)
a2 = (length(p) - 1) * k * log(k)
a3 = (1 - 0.5) * log(length(p))
b = -1/(a1 + a2 + a3)
return(b)
}
Ccomplexity<-function(p){
cc <- jensenDivergence(p) * constant(p) * shannonEntropyNormalized(p)
return(cc)
}
wootters_distance<-function(probability,q){
cc = rep(1/length(probability),length(probability))
dis = sum(sqrt(probability*cc))
dis = acos(dis)
return(dis)
}
complexityF<-function(probability){
entropy = ShannonAux(probability)
qInitial = rep(1/length(probability),length(probability))
qInitial[1] = 1
desequilibrium = jensenDivergence(qInitial) * jensenDivergence(probability)
comp = entropy * desequilibrium
return(comp)
}
bhattacharyyaDistance<-function(probability){
cc = rep(1/length(probability),length(probability))
distance = sum(sqrt(probability*cc))
distance = -log(distance)
distance
}
bhattacharyyaDistance(d)
?acos
